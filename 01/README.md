## [UC](https://codeforces.com/gym/100269/problem/C)
ACM ICPC 2013–2014, NEERC, Northern Subregional Contest, Problem C

Solved at 2022.10.11 (+9)

题意：

给出两个字符串 $S$ 和 $T$，要求找到一对长度之和最短的非空字符串 $A$ 和字符串 $B$，使得将 $S$ 中的 $A$ 子串替换成 $B$ 之后与 $T$ 相等，其中替换为从左到右迭代替换，替换出的 $B$ 的部分不会被接着替换。

题解：

考虑枚举替换哪个子串，我们发现如果确定了替换 $A$，那么其替换的位置 $P$ 根据替换规则确定。接着考虑如何根据 $A$ 确定 $B$。 $B$ 的长度为 $|A|+(|T|-|S|)/|P|$，同时 $B$ 在 $T$ 中第一次出现的位置与 $A$ 在 $S$ 中第一次出现的位置相同，因此可以确定 $B$。

考虑已知 $A$ 的所有出现位置 $P$，可以在 $O(P)$ 的时间里计算出替换后的字符串 $S'$ 的哈希。如果对每个 $A$ 都只计算一次 $S'$，那么将计算时间均摊到 $A$ 的每一次出现，对所有 $A$ 计算 $S'$ 的总复杂度为 $O(n^2)$。

可以一次处理所有长度相同的 $A$。从左到右枚举 $S$ 长度为 $k$ 的子串 $s_i$，如果是第一次出现，那么将 $s_i$ 加入待选的 $A$ 中，并将 $i$ 加入 $s_i$ 的替换位置，否则找到 $s_i$ 的最后一个替换位置 $p_k$，如果 $p_k$ 与 $i$ 位置的子串不重叠则 $i$ 也加入 $s_i$ 的替换位置。每一次处理的复杂度为 $O(n)$。

处理完之后，对每个待选的 $A$ 求出其替换后的字符串哈希，如果与 $T$ 相同则更新答案。


## [DG](https://codeforces.com/gym/101471/problem/G)
ACM ICPC 2017 World Finals, Problem G

Solved at 2022.10.10 (+4)

题意：

一个类生长游戏，若一个格子在上一时刻时周围九宫格内有奇数个邻居（包括自己）被激活，则这个格子会在这一时刻被激活。但是每一次生长后都有可能会出现一位被翻转的噪点。给出一个生长后的状态，求最小的可能的初始状态。

题解：

生长 $2^k$ 次后的状态看着很有规律，但其实是陷阱。

原版的生长游戏是根据形如 $\ge k$ 的阈值来决定是否激活格子的，但本题中是通过异或激活，每一个格子对周围的贡献可以直接通过异或叠加或消除。即用 $S$ 代表状态矩阵，$grow$ 代表一次生长，则 $grow(S_1\oplus S_2)=grow(S_1)\oplus grow(S_2)$

每一个格子在生长后都会影响一个 $3\times 3$ 的九宫格，但噪点的大小只有 $1\times 1$。这导致了一个状态 $S$ 的生长前状态 $grow^{-1}(S)$ 至多只有一个，因为无法构造一个状态 $S'$ 使得 $grow(S')$ 恰好等于一个或两个噪点。

枚举噪点会超时，因此考虑如何找到噪点。可以发现，如果一次生长中没有噪点出现，那么每个激活状态 $S_{i,j}=1$ 都会同时影响 $S'=grow(S)$ 中模 $3$ 余数为 $0,1,2$ 的行和列，因此对 $S'$ 的每一行 $R=S'_i$，模 $3$ 余数为 $0,1,2$ 的列的异或和都应该相等。而当噪点在该行出现时，会导致其中一项不等于其他两项，因此可以通过该性质直接找到噪点所在的行。同理也可以找到噪点所在的列。

找到噪点后去除噪点，然后用类似多项式除法的方式解出状态 $S$ 的生长前状态 $grow^{-1}(S)$，如果不存在，因为每次生长后状态的大小都会严格变大，所以当前的状态就是题目所求的最小初始状态。

## [RB](https://codeforces.com/gym/101142/problem/B)
ACM ICPC 2016–2017, NEERC, Northern Subregional Contest, Problem B

Unsolved.