## [UC](https://codeforces.com/gym/100269/problem/C)
ACM ICPC 2013–2014, NEERC, Northern Subregional Contest, Problem C

Solved at 2022.10.11 (+9)

题意：

给出两个字符串 $S$ 和 $T$，要求找到一对长度之和最短的非空字符串 $A$ 和字符串 $B$，使得将 $S$ 中的 $A$ 子串替换成 $B$ 之后与 $T$ 相等，其中替换为从左到右迭代替换，替换出的 $B$ 的部分不会被接着替换。

题解：

考虑枚举替换哪个子串，我们发现如果确定了替换 $A$，那么其替换的位置 $P$ 根据替换规则确定。接着考虑如何根据 $A$ 确定 $B$。 $B$ 的长度为 $|A|+(|T|-|S|)/|P|$，同时 $B$ 在 $T$ 中第一次出现的位置与 $A$ 在 $S$ 中第一次出现的位置相同，因此可以确定 $B$。

考虑已知 $A$ 的所有出现位置 $P$，可以在 $O(P)$ 的时间里计算出替换后的字符串 $S'$ 的哈希。如果对每个 $A$ 都只计算一次 $S'$，那么将计算时间均摊到 $A$ 的每一次出现，对所有 $A$ 计算 $S'$ 的总复杂度为 $O(n^2)$。

可以一次处理所有长度相同的 $A$。从左到右枚举 $S$ 长度为 $k$ 的子串 $s_i$，如果是第一次出现，那么将 $s_i$ 加入待选的 $A$ 中，并将 $i$ 加入 $s_i$ 的替换位置，否则找到 $s_i$ 的最后一个替换位置 $p_k$，如果 $p_k$ 与 $i$ 位置的子串不重叠则 $i$ 也加入 $s_i$ 的替换位置。每一次处理的复杂度为 $O(n)$。

处理完之后，对每个待选的 $A$ 求出其替换后的字符串哈希，如果与 $T$ 相同则更新答案。


## [DG](https://codeforces.com/gym/101471/problem/G)
ACM ICPC 2017 World Finals, Problem G

Solved at 2022.10.10 (+4)

题意：

一个类生长游戏，若一个格子在上一时刻时周围九宫格内有奇数个邻居（包括自己）被激活，则这个格子会在这一时刻被激活。但是每一次生长后都有可能会出现一位被翻转的噪点。给出一个生长后的状态，求最小的可能的初始状态。

题解：

生长 $2^k$ 次后的状态看着很有规律，但其实是陷阱。

原版的生长游戏是根据形如 $\ge k$ 的阈值来决定是否激活格子的，但本题中是通过异或激活，每一个格子对周围的贡献可以直接通过异或叠加或消除。即用 $S$ 代表状态矩阵，$grow$ 代表一次生长，则 $grow(S_1\oplus S_2)=grow(S_1)\oplus grow(S_2)$

每一个格子在生长后都会影响一个 $3\times 3$ 的九宫格，但噪点的大小只有 $1\times 1$。这导致了一个状态 $S$ 的生长前状态 $grow^{-1}(S)$ 至多只有一个，因为无法构造一个状态 $S'$ 使得 $grow(S')$ 恰好等于一个或两个噪点。

枚举噪点会超时，因此考虑如何找到噪点。可以发现，如果一次生长中没有噪点出现，那么每个激活状态 $S_{i,j}=1$ 都会同时影响 $S'=grow(S)$ 中模 $3$ 余数为 $0,1,2$ 的行和列，因此对 $S'$ 的每一行 $R=S'_i$，模 $3$ 余数为 $0,1,2$ 的列的异或和都应该相等。而当噪点在该行出现时，会导致其中一项不等于其他两项，因此可以通过该性质直接找到噪点所在的行。同理也可以找到噪点所在的列。

找到噪点后去除噪点，然后用类似多项式除法的方式解出状态 $S$ 的生长前状态 $grow^{-1}(S)$，如果不存在，因为每次生长后状态的大小都会严格变大，所以当前的状态就是题目所求的最小初始状态。

## [RB](https://codeforces.com/gym/101142/problem/B)
ACM ICPC 2016–2017, NEERC, Northern Subregional Contest, Problem B

Solved at 2022.10.13 (+7)

题意：

构造一个长度为 $n$ 的 `BG` 字符串 $S$，使得其中有 $a$ 个字符与 `B` 相邻，$b$ 个字符与 `G` 相邻。字符串的第一个字符与最后一个字符相邻。

题解：

$S$ 中相邻的字符 $s_i,s_{i+1}$ 不互相影响贡献，而隔开的字符 $s_i,s_{i+2}$ 会互相影响贡献：$s_i$ 默认贡献为 $2$，如果 $s_{i+2}=s_i$ 则贡献减去 $1$。

考虑将字符串按 $s_i$ 与 $s_{i+2}$ 相邻的规则重构，则问题转化成了在重构后的字符串中，如果相邻的字符是 `BB` 或 `GG`，则对对应的 $a$ 或 $b$ 贡献 $1$；如果是 `BG` 或 `GB`，则对 $a,b$ 都贡献 $1$。

如果 $n=2k+1$，那么重构后会得到一个长度为 $n$ 的字符串；如果 $n=2k$，那么重构后会得到两个长度为 $k$ 的字符串。我们先考虑如何处理单个字符串。

给出 $a,b,n$，考虑如何求出重构后的字符串。不妨令 `BG` 的数量为 $k$，因为字符串循环 `GB` 的数量也为 $k$。根据 $a,b$ 得出 `BB` 和 `GG` 的数量分别为 $a-2k$ 和 $b-2k$。同时四种情况出现的总次数等于 $n$，得出 $a+b-2k=n, k=(n-a-b)/2$。当 $k\in N^*,2k\le n$ 且 $a,b>=2k$ 时可以用 `BB...B GG...G BGBG...BG` 的形式构造，否则解不存在。因为 $k=0$ 时 $a,b$ 最多只有一个 $>0$，所以需要特判 $k=0$ 的情况。

接下来考虑两个字符串的情况。同样，我们先特判有一个或两个字符串中 $k=0$ 的情况，然后考虑如何分配 $a$ 和 $b$ 使得两个字符串都有解。我们已经得出字符串有解的充要条件，因为这些条件除了 $n-a-b$ 为偶数之外都是尽可能均分更容易满足，所以我们可以在 $a_1\approx a/2,b_1\approx b/2$ 的小范围搜索解。如果解存在，则任意解都可以通过重新分配 $a,b$ 到达这个范围，因此这个范围内一定存在解。而如果这个范围内不存在解，则解一定不存在。